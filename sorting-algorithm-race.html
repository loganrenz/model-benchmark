<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sorting Algorithm Race</title>
  <style>
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      margin: 0;
      padding: 20px;
      color: white;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 15px;
      padding: 20px;
      backdrop-filter: blur(10px);
      box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
    }

    h1 {
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.5em;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }

    .algorithms {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
    }

    .algorithm {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 15px;
      text-align: center;
    }

    .algorithm-title {
      font-size: 1.2em;
      margin-bottom: 10px;
      font-weight: bold;
    }

    canvas {
      width: 100%;
      max-width: 400px;
      height: 300px;
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.2);
      display: block;
      margin: 0 auto;
    }

    .stats {
      margin-top: 10px;
      font-size: 0.9em;
      opacity: 0.8;
    }

    .legend {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-top: 20px;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 0.9em;
    }

    .color-box {
      width: 15px;
      height: 15px;
      border-radius: 3px;
    }

    @media (max-width: 768px) {
      .algorithms {
        grid-template-columns: 1fr;
      }

      h1 {
        font-size: 2em;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Sorting Algorithm Race</h1>

    <div class="algorithms">
      <div class="algorithm">
        <div class="algorithm-title">Bubble Sort</div>
        <canvas id="bubble-canvas"></canvas>
        <div class="stats" id="bubble-stats">Comparisons: 0 | Swaps: 0</div>
      </div>

      <div class="algorithm">
        <div class="algorithm-title">Quick Sort</div>
        <canvas id="quick-canvas"></canvas>
        <div class="stats" id="quick-stats">Comparisons: 0 | Swaps: 0</div>
      </div>

      <div class="algorithm">
        <div class="algorithm-title">Merge Sort</div>
        <canvas id="merge-canvas"></canvas>
        <div class="stats" id="merge-stats">Comparisons: 0 | Swaps: 0</div>
      </div>

      <div class="algorithm">
        <div class="algorithm-title">Insertion Sort</div>
        <canvas id="insertion-canvas"></canvas>
        <div class="stats" id="insertion-stats">Comparisons: 0 | Swaps: 0</div>
      </div>
    </div>

    <div class="legend">
      <div class="legend-item">
        <div class="color-box" style="background-color: #3b82f6;"></div>
        <span>Comparing</span>
      </div>
      <div class="legend-item">
        <div class="color-box" style="background-color: #ef4444;"></div>
        <span>Swapping</span>
      </div>
      <div class="legend-item">
        <div class="color-box" style="background-color: #10b981;"></div>
        <span>Sorted</span>
      </div>
    </div>
  </div>

  <script>
    // Configuration
    const ARRAY_SIZE = 40;
    const BAR_WIDTH = 8;
    const BAR_SPACING = 2;
    const ANIMATION_DELAY = 50; // milliseconds
    const COLORS = {
      default: '#6b7280',
      comparing: '#3b82f6',
      swapping: '#ef4444',
      sorted: '#10b981'
    };

    class SortingVisualizer {
      constructor(canvasId, statsId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.statsElement = document.getElementById(statsId);
        this.comparisons = 0;
        this.swaps = 0;
        this.sorted = false;

        // Set canvas size
        this.canvas.width = ARRAY_SIZE * (BAR_WIDTH + BAR_SPACING);
        this.canvas.height = 300;
      }

      generateArray() {
        this.array = [];
        for (let i = 0; i < ARRAY_SIZE; i++) {
          this.array.push(Math.floor(Math.random() * 200) + 20);
        }
        this.comparisons = 0;
        this.swaps = 0;
        this.sorted = false;
      }

      drawArray(highlights = {}) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        for (let i = 0; i < this.array.length; i++) {
          let color = COLORS.default;

          if (highlights.comparing && highlights.comparing.includes(i)) {
            color = COLORS.comparing;
          } else if (highlights.swapping && highlights.swapping.includes(i)) {
            color = COLORS.swapping;
          } else if (this.sorted || (highlights.sorted && highlights.sorted.includes(i))) {
            color = COLORS.sorted;
          }

          this.ctx.fillStyle = color;
          const x = i * (BAR_WIDTH + BAR_SPACING);
          const height = this.array[i];
          this.ctx.fillRect(x, this.canvas.height - height, BAR_WIDTH, height);
        }

        this.updateStats();
      }

      updateStats() {
        this.statsElement.textContent = `Comparisons: ${this.comparisons} | Swaps: ${this.swaps}`;
      }

      async delay() {
        return new Promise(resolve => setTimeout(resolve, ANIMATION_DELAY));
      }

      compare(i, j) {
        this.comparisons++;
        return this.array[i] > this.array[j];
      }

      swap(i, j) {
        [this.array[i], this.array[j]] = [this.array[j], this.array[i]];
        this.swaps++;
      }

      markSorted() {
        this.sorted = true;
        this.drawArray();
      }
    }

    // Bubble Sort Implementation
    class BubbleSort extends SortingVisualizer {
      async sort() {
        this.generateArray();
        this.drawArray();

        for (let i = 0; i < this.array.length - 1; i++) {
          for (let j = 0; j < this.array.length - i - 1; j++) {
            // Highlight comparing elements
            this.drawArray({ comparing: [j, j + 1] });
            await this.delay();

            if (this.compare(j, j + 1)) {
              // Highlight swapping elements
              this.drawArray({ swapping: [j, j + 1] });
              await this.delay();

              this.swap(j, j + 1);
              this.drawArray({ swapping: [j, j + 1] });
              await this.delay();
            }
          }
        }

        this.markSorted();
      }
    }

    // Quick Sort Implementation
    class QuickSort extends SortingVisualizer {
      async sort() {
        this.generateArray();
        this.drawArray();
        await this.quickSort(0, this.array.length - 1);
        this.markSorted();
      }

      async quickSort(low, high) {
        if (low < high) {
          const pivotIndex = await this.partition(low, high);
          await this.quickSort(low, pivotIndex - 1);
          await this.quickSort(pivotIndex + 1, high);
        }
      }

      async partition(low, high) {
        const pivot = this.array[high];
        let i = low - 1;

        for (let j = low; j < high; j++) {
          // Highlight comparing elements
          this.drawArray({ comparing: [j, high] });
          await this.delay();

          if (!this.compare(j, high)) {
            i++;
            // Highlight swapping elements
            this.drawArray({ swapping: [i, j] });
            await this.delay();

            this.swap(i, j);
            this.drawArray({ swapping: [i, j] });
            await this.delay();
          }
        }

        // Highlight swapping pivot
        this.drawArray({ swapping: [i + 1, high] });
        await this.delay();

        this.swap(i + 1, high);
        this.drawArray({ swapping: [i + 1, high] });
        await this.delay();

        return i + 1;
      }
    }

    // Merge Sort Implementation
    class MergeSort extends SortingVisualizer {
      async sort() {
        this.generateArray();
        this.drawArray();
        await this.mergeSort(0, this.array.length - 1);
        this.markSorted();
      }

      async mergeSort(left, right) {
        if (left < right) {
          const mid = Math.floor((left + right) / 2);
          await this.mergeSort(left, mid);
          await this.mergeSort(mid + 1, right);
          await this.merge(left, mid, right);
        }
      }

      async merge(left, mid, right) {
        const leftArray = this.array.slice(left, mid + 1);
        const rightArray = this.array.slice(mid + 1, right + 1);

        let i = 0, j = 0, k = left;

        while (i < leftArray.length && j < rightArray.length) {
          // Highlight comparing elements
          this.drawArray({ comparing: [left + i, mid + 1 + j] });
          await this.delay();

          if (leftArray[i] <= rightArray[j]) {
            this.array[k] = leftArray[i];
            i++;
          } else {
            this.array[k] = rightArray[j];
            j++;
          }
          k++;
          this.swaps++; // Count as swaps for visualization
          this.drawArray();
          await this.delay();
        }

        // Copy remaining elements
        while (i < leftArray.length) {
          this.array[k] = leftArray[i];
          i++;
          k++;
          this.swaps++;
          this.drawArray();
          await this.delay();
        }

        while (j < rightArray.length) {
          this.array[k] = rightArray[j];
          j++;
          k++;
          this.swaps++;
          this.drawArray();
          await this.delay();
        }
      }
    }

    // Insertion Sort Implementation
    class InsertionSort extends SortingVisualizer {
      async sort() {
        this.generateArray();
        this.drawArray();

        for (let i = 1; i < this.array.length; i++) {
          const key = this.array[i];
          let j = i - 1;

          // Highlight comparing elements
          this.drawArray({ comparing: [i] });
          await this.delay();

          while (j >= 0 && this.compare(j, i)) {
            // Highlight swapping elements
            this.drawArray({ swapping: [j, j + 1] });
            await this.delay();

            this.swap(j + 1, j);
            this.drawArray({ swapping: [j, j + 1] });
            await this.delay();

            j--;
          }

          this.array[j + 1] = key;
          this.drawArray();
          await this.delay();
        }

        this.markSorted();
      }
    }

    // Initialize and run all sorting algorithms
    async function runSortingRace() {
      const algorithms = [
        new BubbleSort('bubble-canvas', 'bubble-stats'),
        new QuickSort('quick-canvas', 'quick-stats'),
        new MergeSort('merge-canvas', 'merge-stats'),
        new InsertionSort('insertion-canvas', 'insertion-stats')
      ];

      // Use the same initial array for all algorithms
      const initialArray = [];
      for (let i = 0; i < ARRAY_SIZE; i++) {
        initialArray.push(Math.floor(Math.random() * 200) + 20);
      }

      // Set the same array for all algorithms
      algorithms.forEach(alg => {
        alg.array = [...initialArray];
        alg.drawArray();
      });

      // Run all algorithms simultaneously
      await Promise.all(algorithms.map(alg => alg.sort()));
    }

    // Start the sorting race when the page loads
    window.addEventListener('load', () => {
      runSortingRace();
    });
  </script>
</body>
</html>

