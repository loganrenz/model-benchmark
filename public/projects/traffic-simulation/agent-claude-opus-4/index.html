<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Traffic Light Simulation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    canvas {
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas size
    canvas.width = 900;
    canvas.height = 500;
    
    // Configuration
    const ROAD_Y = 280;
    const ROAD_HEIGHT = 100;
    const LANE_HEIGHT = ROAD_HEIGHT / 2;
    const TRAFFIC_LIGHT_X = 550;
    const STOP_LINE_X = TRAFFIC_LIGHT_X - 60;
    const LIGHT_CYCLE_MS = 4000; // 4 seconds per phase
    
    // Colors
    const colors = {
      sky: '#87CEEB',
      grass: '#228B22',
      road: '#333333',
      roadMarking: '#FFFFFF',
      sidewalk: '#808080',
      lightPoleColor: '#2c2c2c',
      lightHousingColor: '#1a1a1a'
    };
    
    // Car colors palette
    const carColors = [
      { body: '#e74c3c', highlight: '#ff6b6b' }, // Red
      { body: '#3498db', highlight: '#5dade2' }, // Blue
      { body: '#2ecc71', highlight: '#58d68d' }, // Green
      { body: '#9b59b6', highlight: '#bb8fce' }, // Purple
      { body: '#f39c12', highlight: '#f5b041' }, // Orange
      { body: '#1abc9c', highlight: '#48c9b0' }, // Teal
    ];
    
    // Traffic light state
    let isGreen = true;
    let lightTimer = 0;
    let yellowPhase = false;
    
    // Cars array
    let cars = [];
    
    // Car class
    class Car {
      constructor(x, lane) {
        this.x = x;
        this.lane = lane; // 0 = top lane (left to right), 1 = bottom lane (right to left)
        this.width = 60 + Math.random() * 20;
        this.height = 30 + Math.random() * 8;
        this.baseSpeed = 2 + Math.random() * 1.5;
        this.speed = this.baseSpeed;
        this.targetSpeed = this.baseSpeed;
        this.colorScheme = carColors[Math.floor(Math.random() * carColors.length)];
        this.y = this.lane === 0 
          ? ROAD_Y + LANE_HEIGHT / 2 
          : ROAD_Y + LANE_HEIGHT + LANE_HEIGHT / 2;
      }
      
      update(cars) {
        // Determine if car should stop
        const direction = this.lane === 0 ? 1 : -1;
        const frontOfCar = this.lane === 0 ? this.x + this.width : this.x;
        const distanceToLight = this.lane === 0 
          ? STOP_LINE_X - frontOfCar 
          : frontOfCar - (canvas.width - STOP_LINE_X);
        
        // Check if approaching red light (only for lane 0 in this simulation)
        if (this.lane === 0) {
          if (!isGreen && distanceToLight > 0 && distanceToLight < 150) {
            this.targetSpeed = 0;
          } else if (isGreen || distanceToLight < 0 || distanceToLight >= 150) {
            // Check for car ahead
            const carAhead = this.findCarAhead(cars);
            if (carAhead) {
              const gap = carAhead.x - (this.x + this.width);
              if (gap < 40) {
                this.targetSpeed = 0;
              } else if (gap < 80) {
                this.targetSpeed = carAhead.speed * 0.8;
              } else {
                this.targetSpeed = this.baseSpeed;
              }
            } else {
              this.targetSpeed = this.baseSpeed;
            }
          }
        } else {
          // Lane 1 cars just check for cars ahead
          const carAhead = this.findCarAhead(cars);
          if (carAhead) {
            const gap = this.x - (carAhead.x + carAhead.width);
            if (gap < 40) {
              this.targetSpeed = 0;
            } else if (gap < 80) {
              this.targetSpeed = carAhead.speed * 0.8;
            } else {
              this.targetSpeed = this.baseSpeed;
            }
          } else {
            this.targetSpeed = this.baseSpeed;
          }
        }
        
        // Smooth speed transition
        const speedDiff = this.targetSpeed - this.speed;
        this.speed += speedDiff * 0.1;
        
        // Move car
        if (this.lane === 0) {
          this.x += this.speed;
        } else {
          this.x -= this.speed;
        }
      }
      
      findCarAhead(cars) {
        let closestCar = null;
        let minDistance = Infinity;
        
        for (const other of cars) {
          if (other === this || other.lane !== this.lane) continue;
          
          if (this.lane === 0) {
            if (other.x > this.x) {
              const distance = other.x - this.x;
              if (distance < minDistance) {
                minDistance = distance;
                closestCar = other;
              }
            }
          } else {
            if (other.x < this.x) {
              const distance = this.x - other.x;
              if (distance < minDistance) {
                minDistance = distance;
                closestCar = other;
              }
            }
          }
        }
        
        return closestCar;
      }
      
      draw() {
        ctx.save();
        ctx.translate(this.x + this.width / 2, this.y);
        
        if (this.lane === 1) {
          ctx.scale(-1, 1);
        }
        
        // Car shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(4, this.height / 2 + 4, this.width / 2 + 2, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Car body
        ctx.fillStyle = this.colorScheme.body;
        ctx.beginPath();
        ctx.roundRect(-this.width / 2, -this.height / 2, this.width, this.height, 8);
        ctx.fill();
        
        // Car top/cabin
        const cabinWidth = this.width * 0.5;
        const cabinHeight = this.height * 0.65;
        ctx.fillStyle = this.colorScheme.highlight;
        ctx.beginPath();
        ctx.roundRect(-cabinWidth / 2 + 5, -cabinHeight / 2 - 2, cabinWidth, cabinHeight, 5);
        ctx.fill();
        
        // Windows
        ctx.fillStyle = '#1a3a5c';
        ctx.beginPath();
        ctx.roundRect(-cabinWidth / 2 + 8, -cabinHeight / 2 + 2, cabinWidth - 6, cabinHeight - 8, 3);
        ctx.fill();
        
        // Window reflection
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        ctx.roundRect(-cabinWidth / 2 + 10, -cabinHeight / 2 + 4, cabinWidth / 3, cabinHeight - 12, 2);
        ctx.fill();
        
        // Headlight
        ctx.fillStyle = '#ffff99';
        ctx.beginPath();
        ctx.ellipse(this.width / 2 - 5, -5, 4, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(this.width / 2 - 5, 5, 4, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Tail light
        ctx.fillStyle = '#ff3333';
        ctx.beginPath();
        ctx.ellipse(-this.width / 2 + 5, -6, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(-this.width / 2 + 5, 6, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Wheels
        ctx.fillStyle = '#222';
        ctx.beginPath();
        ctx.ellipse(-this.width / 3, this.height / 2 - 2, 8, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(this.width / 3, this.height / 2 - 2, 8, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Wheel caps
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.ellipse(-this.width / 3, this.height / 2 - 2, 4, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.ellipse(this.width / 3, this.height / 2 - 2, 4, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      isOffscreen() {
        if (this.lane === 0) {
          return this.x > canvas.width + 100;
        } else {
          return this.x + this.width < -100;
        }
      }
    }
    
    // Initialize cars
    function spawnCar(lane) {
      const x = lane === 0 ? -80 : canvas.width + 80;
      cars.push(new Car(x, lane));
    }
    
    // Draw background
    function drawBackground() {
      // Sky gradient
      const skyGradient = ctx.createLinearGradient(0, 0, 0, ROAD_Y);
      skyGradient.addColorStop(0, '#1e3c72');
      skyGradient.addColorStop(1, '#2a5298');
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, canvas.width, ROAD_Y);
      
      // Sun
      const sunGradient = ctx.createRadialGradient(750, 80, 0, 750, 80, 60);
      sunGradient.addColorStop(0, '#fff7e6');
      sunGradient.addColorStop(0.3, '#ffd93d');
      sunGradient.addColorStop(1, 'transparent');
      ctx.fillStyle = sunGradient;
      ctx.beginPath();
      ctx.arc(750, 80, 60, 0, Math.PI * 2);
      ctx.fill();
      
      // Clouds
      drawCloud(100, 60, 1);
      drawCloud(300, 100, 0.7);
      drawCloud(600, 50, 0.9);
      
      // Grass area
      const grassGradient = ctx.createLinearGradient(0, ROAD_Y + ROAD_HEIGHT, 0, canvas.height);
      grassGradient.addColorStop(0, '#228B22');
      grassGradient.addColorStop(1, '#196619');
      ctx.fillStyle = grassGradient;
      ctx.fillRect(0, ROAD_Y + ROAD_HEIGHT, canvas.width, canvas.height - ROAD_Y - ROAD_HEIGHT);
      
      // Grass texture
      ctx.fillStyle = '#1a7a1a';
      for (let i = 0; i < 50; i++) {
        const gx = Math.random() * canvas.width;
        const gy = ROAD_Y + ROAD_HEIGHT + 10 + Math.random() * (canvas.height - ROAD_Y - ROAD_HEIGHT - 20);
        ctx.beginPath();
        ctx.moveTo(gx, gy);
        ctx.lineTo(gx - 2, gy - 8);
        ctx.lineTo(gx + 2, gy - 8);
        ctx.closePath();
        ctx.fill();
      }
      
      // Upper grass
      ctx.fillStyle = grassGradient;
      ctx.fillRect(0, ROAD_Y - 20, canvas.width, 20);
    }
    
    function drawCloud(x, y, scale) {
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();
      ctx.arc(0, 0, 25, 0, Math.PI * 2);
      ctx.arc(30, -5, 30, 0, Math.PI * 2);
      ctx.arc(60, 0, 25, 0, Math.PI * 2);
      ctx.arc(30, 10, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();
    }
    
    // Draw road
    function drawRoad() {
      // Road base
      ctx.fillStyle = colors.road;
      ctx.fillRect(0, ROAD_Y, canvas.width, ROAD_HEIGHT);
      
      // Road edges
      ctx.fillStyle = '#555';
      ctx.fillRect(0, ROAD_Y, canvas.width, 4);
      ctx.fillRect(0, ROAD_Y + ROAD_HEIGHT - 4, canvas.width, 4);
      
      // Center line (dashed yellow)
      ctx.strokeStyle = '#FFD700';
      ctx.lineWidth = 3;
      ctx.setLineDash([30, 20]);
      ctx.beginPath();
      ctx.moveTo(0, ROAD_Y + ROAD_HEIGHT / 2);
      ctx.lineTo(canvas.width, ROAD_Y + ROAD_HEIGHT / 2);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Lane markings (white dashes)
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      ctx.lineWidth = 2;
      ctx.setLineDash([15, 25]);
      ctx.beginPath();
      ctx.moveTo(0, ROAD_Y + LANE_HEIGHT / 2);
      ctx.lineTo(canvas.width, ROAD_Y + LANE_HEIGHT / 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, ROAD_Y + LANE_HEIGHT + LANE_HEIGHT / 2);
      ctx.lineTo(canvas.width, ROAD_Y + LANE_HEIGHT + LANE_HEIGHT / 2);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Stop line
      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(STOP_LINE_X, ROAD_Y, 8, LANE_HEIGHT);
    }
    
    // Draw traffic light
    function drawTrafficLight() {
      const x = TRAFFIC_LIGHT_X;
      const poleBase = ROAD_Y + ROAD_HEIGHT + 10;
      
      // Pole shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.ellipse(x + 5, poleBase + 5, 15, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      
      // Pole
      ctx.fillStyle = colors.lightPoleColor;
      ctx.fillRect(x - 5, ROAD_Y - 120, 10, poleBase - ROAD_Y + 120);
      
      // Pole highlight
      ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.fillRect(x - 5, ROAD_Y - 120, 3, poleBase - ROAD_Y + 120);
      
      // Traffic light housing
      const housingX = x - 25;
      const housingY = ROAD_Y - 110;
      const housingWidth = 50;
      const housingHeight = 100;
      
      // Housing shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.beginPath();
      ctx.roundRect(housingX + 5, housingY + 5, housingWidth, housingHeight, 8);
      ctx.fill();
      
      // Housing body
      ctx.fillStyle = colors.lightHousingColor;
      ctx.beginPath();
      ctx.roundRect(housingX, housingY, housingWidth, housingHeight, 8);
      ctx.fill();
      
      // Housing border
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(housingX, housingY, housingWidth, housingHeight, 8);
      ctx.stroke();
      
      // Visor
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.moveTo(housingX + housingWidth, housingY + 10);
      ctx.lineTo(housingX + housingWidth + 15, housingY + 5);
      ctx.lineTo(housingX + housingWidth + 15, housingY + housingHeight - 5);
      ctx.lineTo(housingX + housingWidth, housingY + housingHeight - 10);
      ctx.closePath();
      ctx.fill();
      
      // Light positions
      const lightRadius = 15;
      const redY = housingY + 25;
      const yellowY = housingY + 50;
      const greenY = housingY + 75;
      
      // Light backgrounds (dark circles)
      ctx.fillStyle = '#111';
      [redY, yellowY, greenY].forEach(ly => {
        ctx.beginPath();
        ctx.arc(x, ly, lightRadius + 2, 0, Math.PI * 2);
        ctx.fill();
      });
      
      // Red light
      const redOn = !isGreen && !yellowPhase;
      ctx.fillStyle = redOn ? '#ff0000' : '#4a0000';
      ctx.beginPath();
      ctx.arc(x, redY, lightRadius, 0, Math.PI * 2);
      ctx.fill();
      if (redOn) {
        // Glow effect
        const redGlow = ctx.createRadialGradient(x, redY, 0, x, redY, lightRadius * 2);
        redGlow.addColorStop(0, 'rgba(255, 0, 0, 0.6)');
        redGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = redGlow;
        ctx.beginPath();
        ctx.arc(x, redY, lightRadius * 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Yellow light
      const yellowOn = yellowPhase;
      ctx.fillStyle = yellowOn ? '#ffff00' : '#4a4a00';
      ctx.beginPath();
      ctx.arc(x, yellowY, lightRadius, 0, Math.PI * 2);
      ctx.fill();
      if (yellowOn) {
        const yellowGlow = ctx.createRadialGradient(x, yellowY, 0, x, yellowY, lightRadius * 2);
        yellowGlow.addColorStop(0, 'rgba(255, 255, 0, 0.6)');
        yellowGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = yellowGlow;
        ctx.beginPath();
        ctx.arc(x, yellowY, lightRadius * 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Green light
      const greenOn = isGreen && !yellowPhase;
      ctx.fillStyle = greenOn ? '#00ff00' : '#004a00';
      ctx.beginPath();
      ctx.arc(x, greenY, lightRadius, 0, Math.PI * 2);
      ctx.fill();
      if (greenOn) {
        const greenGlow = ctx.createRadialGradient(x, greenY, 0, x, greenY, lightRadius * 2);
        greenGlow.addColorStop(0, 'rgba(0, 255, 0, 0.6)');
        greenGlow.addColorStop(1, 'transparent');
        ctx.fillStyle = greenGlow;
        ctx.beginPath();
        ctx.arc(x, greenY, lightRadius * 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Light reflections
      [redY, yellowY, greenY].forEach(ly => {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.beginPath();
        ctx.arc(x - 5, ly - 5, 5, 0, Math.PI * 2);
        ctx.fill();
      });
    }
    
    // Draw buildings in background
    function drawBuildings() {
      const buildings = [
        { x: 50, width: 80, height: 140, color: '#4a5568' },
        { x: 150, width: 100, height: 180, color: '#2d3748' },
        { x: 280, width: 70, height: 120, color: '#4a5568' },
        { x: 700, width: 90, height: 160, color: '#2d3748' },
        { x: 810, width: 80, height: 130, color: '#4a5568' },
      ];
      
      buildings.forEach(b => {
        const baseY = ROAD_Y - 20;
        
        // Building shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(b.x + 5, baseY - b.height + 5, b.width, b.height);
        
        // Building body
        ctx.fillStyle = b.color;
        ctx.fillRect(b.x, baseY - b.height, b.width, b.height);
        
        // Windows
        const windowRows = Math.floor(b.height / 25);
        const windowCols = Math.floor(b.width / 20);
        
        for (let row = 0; row < windowRows; row++) {
          for (let col = 0; col < windowCols; col++) {
            const wx = b.x + 10 + col * 18;
            const wy = baseY - b.height + 15 + row * 22;
            const isLit = Math.random() > 0.3;
            ctx.fillStyle = isLit ? '#ffd93d' : '#1a1a2e';
            ctx.fillRect(wx, wy, 10, 12);
          }
        }
        
        // Roof detail
        ctx.fillStyle = '#1a202c';
        ctx.fillRect(b.x, baseY - b.height, b.width, 5);
      });
    }
    
    // Update traffic light
    function updateTrafficLight(deltaTime) {
      lightTimer += deltaTime;
      
      if (lightTimer >= LIGHT_CYCLE_MS) {
        lightTimer = 0;
        if (yellowPhase) {
          yellowPhase = false;
          isGreen = !isGreen;
        } else if (!isGreen) {
          // Red is on, switch to green
          isGreen = true;
        } else {
          // Green is on, switch to yellow first
          yellowPhase = true;
          lightTimer = LIGHT_CYCLE_MS - 1000; // Yellow lasts 1 second
        }
      }
    }
    
    // Spawn management
    let spawnTimer = 0;
    const SPAWN_INTERVAL = 2000;
    
    function manageSpawning(deltaTime) {
      spawnTimer += deltaTime;
      
      if (spawnTimer >= SPAWN_INTERVAL) {
        spawnTimer = 0;
        
        // Check if we can spawn in lane 0
        const lane0Clear = !cars.some(c => c.lane === 0 && c.x < 100);
        if (lane0Clear && Math.random() > 0.3) {
          spawnCar(0);
        }
        
        // Occasionally spawn in lane 1
        const lane1Clear = !cars.some(c => c.lane === 1 && c.x > canvas.width - 100);
        if (lane1Clear && Math.random() > 0.6) {
          spawnCar(1);
        }
      }
    }
    
    // Main animation loop
    let lastTime = 0;
    
    function animate(currentTime) {
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw scene
      drawBackground();
      drawBuildings();
      drawRoad();
      
      // Update and draw cars
      cars.forEach(car => car.update(cars));
      cars.forEach(car => car.draw());
      
      // Remove offscreen cars
      cars = cars.filter(car => !car.isOffscreen());
      
      // Update traffic light
      updateTrafficLight(deltaTime);
      
      // Draw traffic light
      drawTrafficLight();
      
      // Manage car spawning
      manageSpawning(deltaTime);
      
      requestAnimationFrame(animate);
    }
    
    // Start simulation
    // Initial cars
    spawnCar(0);
    setTimeout(() => spawnCar(0), 500);
    setTimeout(() => spawnCar(1), 1000);
    
    requestAnimationFrame(animate);
  </script>
</body>
</html>
