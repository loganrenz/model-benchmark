<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Custom Traffic Simulator</title>
    <style>
      :root {
        color-scheme: dark;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      }
      .wrap {
        width: min(1080px, 96vw);
        margin: 32px auto;
        background: linear-gradient(145deg, #0a0e1e, #151824);
        border: 2px solid #2a3f5f;
        border-radius: 20px;
        box-shadow: 0 40px 100px rgba(0, 0, 0, 0.6);
        position: relative;
        overflow: hidden;
      }
      .glow-border {
        position: absolute;
        inset: -2px;
        background: linear-gradient(45deg, #667eea, #764ba2, #f093fb, #4facfe);
        background-size: 400% 400%;
        animation: gradientShift 8s ease infinite;
        border-radius: 20px;
        opacity: 0.3;
        z-index: -1;
      }
      @keyframes gradientShift {
        0% { background-position: 0% 50%; }
        50% { background-position: 100% 50%; }
        100% { background-position: 0% 50%; }
      }
      .frame {
        position: relative;
        padding: 20px;
      }
      .info-panel {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 16px;
        margin-bottom: 16px;
        background: rgba(20, 30, 48, 0.8);
        border: 1px solid rgba(102, 126, 234, 0.3);
        border-radius: 12px;
        backdrop-filter: blur(10px);
      }
      .light-indicator {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .light-label {
        font-size: 12px;
        color: #8b9dc3;
        text-transform: uppercase;
        letter-spacing: 1px;
        margin-right: 8px;
      }
      .lamp {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #1a2332;
        border: 2px solid #2a3f5f;
        transition: all 0.3s ease;
        position: relative;
      }
      .lamp.active {
        border-color: currentColor;
        box-shadow: 0 0 20px currentColor, inset 0 0 10px currentColor;
      }
      .lamp.green { color: #10b981; }
      .lamp.yellow { color: #fbbf24; }
      .lamp.red { color: #ef4444; }
      .lamp.active::after {
        content: '';
        position: absolute;
        inset: -8px;
        border-radius: 50%;
        background: currentColor;
        opacity: 0.2;
        animation: pulse 2s ease-in-out infinite;
      }
      @keyframes pulse {
        0%, 100% { transform: scale(1); opacity: 0.2; }
        50% { transform: scale(1.3); opacity: 0.1; }
      }
      .stats {
        display: flex;
        gap: 20px;
        font-size: 13px;
        color: #8b9dc3;
      }
      .stat-item {
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      .stat-label {
        font-size: 10px;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        opacity: 0.7;
      }
      .stat-value {
        font-size: 18px;
        font-weight: bold;
        color: #667eea;
        margin-top: 2px;
      }
      canvas {
        width: 100%;
        height: 380px;
        display: block;
        background: linear-gradient(180deg, #0f172a 0%, #1e293b 100%);
        border-radius: 14px;
        border: 1px solid #334155;
        box-shadow: inset 0 2px 20px rgba(0, 0, 0, 0.5);
      }
      @media (max-width: 600px) {
        .wrap {
          margin: 16px auto;
        }
        .frame {
          padding: 14px;
        }
        .info-panel {
          flex-direction: column;
          gap: 12px;
          align-items: flex-start;
        }
        .stats {
          width: 100%;
          justify-content: space-around;
        }
        canvas {
          height: 320px;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="glow-border"></div>
      <div class="frame">
        <div class="info-panel">
          <div class="light-indicator">
            <span class="light-label">Traffic Light:</span>
            <div class="lamp green" id="lamp-green"></div>
            <div class="lamp yellow" id="lamp-yellow"></div>
            <div class="lamp red" id="lamp-red"></div>
          </div>
          <div class="stats">
            <div class="stat-item">
              <span class="stat-label">Cars</span>
              <span class="stat-value" id="car-count">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Queue</span>
              <span class="stat-value" id="queue-count">0</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">Time</span>
              <span class="stat-value" id="elapsed-time">0s</span>
            </div>
          </div>
        </div>
        <canvas id="sim" width="1060" height="380"></canvas>
      </div>
    </div>

    <script>
      const canvas = document.getElementById('sim');
      const ctx = canvas.getContext('2d');

      // Lane configuration - three lanes instead of two for variety
      const lanes = [120, 180, 240];
      const roadTop = 80;
      const roadBottom = 300;
      const stopLineX = 520;

      // Traffic light phases with different timings
      const phases = [
        { name: 'green', color: '#10b981', duration: 6 },
        { name: 'yellow', color: '#fbbf24', duration: 2.5 },
        { name: 'red', color: '#ef4444', duration: 4.5 }
      ];

      const light = { phase: phases[0], index: 0, timer: 0 };
      const cars = [];
      let totalTime = 0;

      // Different color palette for custom feel
      const carColors = ['#667eea', '#f093fb', '#4facfe', '#43e97b', '#fa709a', '#fee140', '#30cfd0'];

      // Easing function for smooth acceleration
      function easeInOut(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
      }

      function spawnCar() {
        const lane = lanes[Math.floor(Math.random() * lanes.length)];
        const baseSpeed = 75 + Math.random() * 60;
        const color = carColors[Math.floor(Math.random() * carColors.length)];
        cars.push({
          x: -70 - Math.random() * 250,
          y: lane,
          width: 50,
          height: 22,
          speed: baseSpeed,
          targetSpeed: baseSpeed,
          color,
          accel: 35 + Math.random() * 40,
          id: Math.random().toString(36).substr(2, 9)
        });
      }

      function cycleLight(delta) {
        light.timer += delta;
        if (light.timer >= light.phase.duration) {
          light.index = (light.index + 1) % phases.length;
          light.phase = phases[light.index];
          light.timer = 0;
        }
      }

      function updateCars(delta) {
        let queueCount = 0;
        
        cars.sort((a, b) => a.x - b.x);
        
        cars.forEach((car) => {
          // Find car ahead in same lane
          const ahead = cars.find((c) => c.y === car.y && c.x > car.x);
          const gapAhead = ahead ? ahead.x - (car.x + car.width) : Infinity;

          // Determine if should stop for light
          const shouldStopForLight =
            (light.phase.name === 'red' && car.x + car.width >= stopLineX - 8) ||
            (light.phase.name === 'yellow' && car.x + car.width >= stopLineX - 30);

          let targetSpeed = car.targetSpeed;
          let shouldStop = false;

          // Light logic
          if (shouldStopForLight) {
            const distanceToLine = stopLineX - (car.x + car.width);
            if (distanceToLine <= 0) {
              shouldStop = true;
              if (car.x + car.width < stopLineX + 5) {
                queueCount++;
              }
            } else {
              // Gradual slowdown
              targetSpeed = Math.min(targetSpeed, Math.max(0, distanceToLine * 1.5));
            }
          }

          // Collision avoidance
          if (gapAhead < 20) {
            shouldStop = true;
          } else if (gapAhead < 80) {
            targetSpeed = Math.min(targetSpeed, gapAhead * 1.4);
          }

          // Apply acceleration/deceleration with smooth easing
          if (shouldStop) {
            car.speed = Math.max(0, car.speed - car.accel * delta * 2);
          } else {
            const speedDiff = targetSpeed - car.speed;
            const t = Math.min(1, Math.abs(speedDiff) / (car.accel * 2));
            car.speed += easeInOut(t) * Math.sign(speedDiff) * delta * car.accel;
            car.speed = Math.max(25, Math.min(car.speed, car.targetSpeed));
          }

          car.x += car.speed * delta;
        });

        // Remove off-screen cars
        for (let i = cars.length - 1; i >= 0; i--) {
          if (cars[i].x - cars[i].width > canvas.width + 100) {
            cars.splice(i, 1);
          }
        }

        return queueCount;
      }

      let spawnTimer = 0;
      function update(delta) {
        totalTime += delta;
        
        // Spawn cars at intervals
        spawnTimer += delta;
        if (spawnTimer > 0.9 + Math.random() * 0.9) {
          spawnCar();
          spawnTimer = 0;
        }

        cycleLight(delta);
        const queueCount = updateCars(delta);
        draw(queueCount);
        updateUI(queueCount);
      }

      function drawRoad() {
        // Road surface with gradient
        const gradient = ctx.createLinearGradient(0, roadTop, 0, roadBottom);
        gradient.addColorStop(0, '#0f172a');
        gradient.addColorStop(0.5, '#1e293b');
        gradient.addColorStop(1, '#0f172a');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, roadTop, canvas.width, roadBottom - roadTop);

        // Lane markers
        ctx.setLineDash([20, 15]);
        ctx.lineWidth = 2.5;
        ctx.strokeStyle = 'rgba(100, 116, 139, 0.5)';
        
        // Draw lane lines
        const laneY1 = (lanes[0] + lanes[1]) / 2;
        const laneY2 = (lanes[1] + lanes[2]) / 2;
        
        ctx.beginPath();
        ctx.moveTo(0, laneY1);
        ctx.lineTo(canvas.width, laneY1);
        ctx.moveTo(0, laneY2);
        ctx.lineTo(canvas.width, laneY2);
        ctx.stroke();
        ctx.setLineDash([]);

        // Road edges
        ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, roadTop);
        ctx.lineTo(canvas.width, roadTop);
        ctx.moveTo(0, roadBottom);
        ctx.lineTo(canvas.width, roadBottom);
        ctx.stroke();

        // Stop line with glow effect
        const stopGradient = ctx.createLinearGradient(stopLineX - 10, 0, stopLineX + 10, 0);
        stopGradient.addColorStop(0, 'rgba(102, 126, 234, 0)');
        stopGradient.addColorStop(0.5, 'rgba(102, 126, 234, 0.4)');
        stopGradient.addColorStop(1, 'rgba(102, 126, 234, 0)');
        ctx.fillStyle = stopGradient;
        ctx.fillRect(stopLineX - 10, roadTop, 20, roadBottom - roadTop);

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 10]);
        ctx.beginPath();
        ctx.moveTo(stopLineX, roadTop);
        ctx.lineTo(stopLineX, roadBottom);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      function drawLight() {
        ctx.save();
        ctx.translate(stopLineX + 35, roadTop - 20);
        
        // Light pole
        ctx.fillStyle = '#1f2937';
        ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
        ctx.shadowBlur = 10;
        ctx.fillRect(-10, 0, 20, roadBottom - roadTop + 50);
        ctx.shadowBlur = 0;

        // Traffic light housing
        ctx.fillStyle = '#0f172a';
        ctx.strokeStyle = '#374151';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(-20, 15, 40, 100, 14);
        ctx.fill();
        ctx.stroke();

        // Light circles
        const lights = [
          { name: 'red', color: '#ef4444', y: 32 },
          { name: 'yellow', color: '#fbbf24', y: 62 },
          { name: 'green', color: '#10b981', y: 92 }
        ];
        
        lights.forEach(({ name, color, y }) => {
          const isActive = light.phase.name === name;
          
          // Outer glow
          if (isActive) {
            const glowGradient = ctx.createRadialGradient(0, y, 0, 0, y, 25);
            glowGradient.addColorStop(0, color + 'aa');
            glowGradient.addColorStop(1, color + '00');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(0, y, 25, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Light bulb
          ctx.fillStyle = isActive ? color : 'rgba(71, 85, 105, 0.4)';
          ctx.beginPath();
          ctx.arc(0, y, 10, 0, Math.PI * 2);
          ctx.fill();
          
          // Highlight
          if (isActive) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.beginPath();
            ctx.arc(-3, y - 3, 4, 0, Math.PI * 2);
            ctx.fill();
          }
        });
        
        ctx.restore();
      }

      function drawCars() {
        cars.forEach((car) => {
          ctx.save();
          ctx.translate(car.x, car.y);
          
          // Car shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.fillRect(2, -car.height / 2 + 2, car.width, car.height);
          
          // Car body with gradient
          const carGradient = ctx.createLinearGradient(0, -car.height / 2, 0, car.height / 2);
          carGradient.addColorStop(0, car.color);
          carGradient.addColorStop(1, adjustBrightness(car.color, -20));
          ctx.fillStyle = carGradient;
          ctx.shadowColor = car.color;
          ctx.shadowBlur = 15;
          ctx.fillRoundRect(0, -car.height / 2, car.width, car.height, 8);
          ctx.shadowBlur = 0;
          
          // Windshield
          ctx.fillStyle = 'rgba(30, 41, 59, 0.7)';
          ctx.fillRoundRect(8, -car.height / 2 + 3, car.width - 16, car.height - 8, 5);
          
          // Headlights
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.fillRect(car.width - 4, -car.height / 2 + 4, 3, 4);
          ctx.fillRect(car.width - 4, car.height / 2 - 8, 3, 4);
          
          ctx.restore();
        });
      }

      function adjustBrightness(color, amount) {
        const hex = color.replace('#', '');
        const num = parseInt(hex, 16);
        const r = Math.max(0, Math.min(255, ((num >> 16) & 0xFF) + amount));
        const g = Math.max(0, Math.min(255, ((num >> 8) & 0xFF) + amount));
        const b = Math.max(0, Math.min(255, (num & 0xFF) + amount));
        return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
      }

      function updateUI(queueCount) {
        // Update light indicators
        document.querySelectorAll('.lamp').forEach(lamp => lamp.classList.remove('active'));
        document.getElementById('lamp-' + light.phase.name).classList.add('active');
        
        // Update stats
        document.getElementById('car-count').textContent = cars.length;
        document.getElementById('queue-count').textContent = queueCount;
        document.getElementById('elapsed-time').textContent = Math.floor(totalTime) + 's';
      }

      function draw(queueCount) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawRoad();
        drawLight();
        drawCars();
      }

      // Polyfill for roundRect if needed
      if (!ctx.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
          if (w < 2 * r) r = w / 2;
          if (h < 2 * r) r = h / 2;
          this.beginPath();
          this.moveTo(x + r, y);
          this.arcTo(x + w, y, x + w, y + h, r);
          this.arcTo(x + w, y + h, x, y + h, r);
          this.arcTo(x, y + h, x, y, r);
          this.arcTo(x, y, x + w, y, r);
          this.closePath();
          return this;
        };
      }

      CanvasRenderingContext2D.prototype.fillRoundRect = function (x, y, w, h, r) {
        this.roundRect(x, y, w, h, r);
        this.fill();
      };

      // Animation loop
      let last = performance.now();
      function frame(now) {
        const delta = Math.min(0.05, (now - last) / 1000);
        last = now;
        update(delta);
        requestAnimationFrame(frame);
      }

      // Initialize with a few cars
      spawnCar();
      spawnCar();
      spawnCar();
      requestAnimationFrame(frame);
    </script>
  </body>
</html>
