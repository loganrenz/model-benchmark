<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Traffic Simulator Reference</title>
    <style>
      :root {
        color-scheme: dark;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background: radial-gradient(circle at 20% 20%, #0d1b2a, #05070c 50%),
          radial-gradient(circle at 80% 0%, #111827, #05070c 48%);
      }
      .wrap {
        width: min(1080px, 96vw);
        margin: 32px auto;
        background: #070d18dd;
        border: 1px solid #1f2937;
        border-radius: 18px;
        box-shadow: 0 30px 90px #020617;
        backdrop-filter: blur(8px);
        position: relative;
        overflow: hidden;
      }
      .glow {
        position: absolute;
        inset: 0;
        background: radial-gradient(120px at 12% 18%, rgba(99, 102, 241, 0.14), transparent 50%),
          radial-gradient(140px at 86% 18%, rgba(34, 197, 94, 0.12), transparent 52%),
          radial-gradient(180px at 50% 0%, rgba(34, 211, 238, 0.12), transparent 60%);
        pointer-events: none;
      }
      .frame {
        position: relative;
        padding: 14px 16px 18px;
      }
      .status {
        position: absolute;
        top: 12px;
        right: 14px;
        display: flex;
        gap: 8px;
        padding: 8px 10px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.7);
        border: 1px solid rgba(59, 130, 246, 0.18);
        box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
      }
      .status .lamp {
        width: 12px;
        height: 12px;
        border-radius: 999px;
        background: #334155;
        box-shadow: 0 0 12px rgba(51, 65, 85, 0.5);
        border: 1px solid #0f172a;
      }
      .status .lamp.on.green {
        background: #22c55e;
        box-shadow: 0 0 18px rgba(34, 197, 94, 0.8);
      }
      .status .lamp.on.yellow {
        background: #eab308;
        box-shadow: 0 0 18px rgba(234, 179, 8, 0.8);
      }
      .status .lamp.on.red {
        background: #ef4444;
        box-shadow: 0 0 18px rgba(239, 68, 68, 0.8);
      }
      canvas {
        width: 100%;
        height: 360px;
        display: block;
        background: radial-gradient(circle at 50% 50%, #0f172a, #0b1220 72%);
        border-radius: 16px;
        border: 1px solid #1f2937;
        box-shadow: inset 0 20px 60px rgba(0, 0, 0, 0.45);
      }
      @media (max-width: 600px) {
        .wrap {
          margin: 16px auto;
        }
        .frame {
          padding: 12px 12px 16px;
        }
        canvas {
          height: 300px;
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div class="glow"></div>
      <div class="frame">
        <div class="status" aria-hidden="true">
          <span class="lamp" id="lamp-green"></span>
          <span class="lamp" id="lamp-yellow"></span>
          <span class="lamp" id="lamp-red"></span>
        </div>
        <canvas id="sim" width="1060" height="360"></canvas>
      </div>
    </div>

    <script>
      const canvas = document.getElementById('sim');
      const ctx = canvas.getContext('2d');

      const lanes = [140, 200];
      const roadTop = 110;
      const roadBottom = 230;
      const stopLineX = 540;

      const phases = [
        { name: 'green', color: '#22c55e', duration: 7 },
        { name: 'yellow', color: '#eab308', duration: 2 },
        { name: 'red', color: '#ef4444', duration: 5 }
      ];

      const light = { phase: phases[0], index: 0, timer: 0 };
      const cars = [];

      const palette = ['#38bdf8', '#a78bfa', '#f472b6', '#22d3ee', '#f97316', '#c084fc'];

      function easeOut(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      function spawnCar() {
        const lane = lanes[Math.floor(Math.random() * lanes.length)];
        const baseSpeed = 80 + Math.random() * 50;
        const color = palette[Math.floor(Math.random() * palette.length)];
        cars.push({
          x: -60 - Math.random() * 220,
          y: lane,
          width: 46,
          height: 18,
          speed: baseSpeed,
          targetSpeed: baseSpeed,
          color,
          accel: 40 + Math.random() * 30,
          id: crypto.randomUUID()
        });
      }

      function cycleLight(delta) {
        light.timer += delta;
        if (light.timer >= light.phase.duration) {
          light.index = (light.index + 1) % phases.length;
          light.phase = phases[light.index];
          light.timer = 0;
        }
      }

      function updateCars(delta) {
        const queueCounts = { [lanes[0]]: 0, [lanes[1]]: 0 };

        cars.sort((a, b) => a.x - b.x);
        cars.forEach((car, index) => {
          const ahead = cars.find((c) => c.y === car.y && c.x > car.x);
          const gapAhead = ahead ? ahead.x - (car.x + car.width) : Infinity;

          const stoppingForLight =
            (light.phase.name === 'red' && car.x + car.width >= stopLineX - 6) ||
            (light.phase.name === 'yellow' && car.x + car.width >= stopLineX - 24);

          let canMove = true;
          let desiredSpeed = car.targetSpeed;

          if (stoppingForLight) {
            const distanceToLine = stopLineX - (car.x + car.width);
            if (distanceToLine <= 0) {
              canMove = false;
              queueCounts[car.y] += 1;
            } else {
              desiredSpeed = Math.min(desiredSpeed, Math.max(0, distanceToLine * 1.3));
            }
          }

          if (gapAhead < 18) {
            canMove = false;
          } else if (gapAhead < 60) {
            desiredSpeed = Math.min(desiredSpeed, gapAhead * 1.2);
          }

          if (!canMove) {
            car.speed = Math.max(0, car.speed - car.accel * delta * 1.6);
          } else {
            const speedDiff = desiredSpeed - car.speed;
            car.speed += easeOut(Math.min(1, Math.abs(speedDiff) / car.accel)) * Math.sign(speedDiff) * delta * car.accel;
            car.speed = Math.max(30, Math.min(car.speed, car.targetSpeed));
          }

          car.x += car.speed * delta;
        });

        for (let i = cars.length - 1; i >= 0; i--) {
          if (cars[i].x - cars[i].width > canvas.width + 80) {
            cars.splice(i, 1);
          }
        }

        return queueCounts;
      }

      let spawnTimer = 0;
      function update(delta) {
        spawnTimer += delta;
        if (spawnTimer > 1.1 + Math.random() * 0.8) {
          spawnCar();
          spawnTimer = 0;
        }

        cycleLight(delta);
        const queues = updateCars(delta);
        draw(queues);
      }

      function drawRoad() {
        ctx.fillStyle = '#0b1220';
        ctx.fillRect(0, roadTop, canvas.width, roadBottom - roadTop);

        ctx.setLineDash([16, 12]);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.beginPath();
        ctx.moveTo(0, 170);
        ctx.lineTo(canvas.width, 170);
        ctx.moveTo(0, 210);
        ctx.lineTo(canvas.width, 210);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = 'rgba(99,102,241,0.22)';
        ctx.fillRect(stopLineX - 4, roadTop, 8, roadBottom - roadTop);

        ctx.strokeStyle = 'rgba(255,255,255,0.12)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(stopLineX, roadTop);
        ctx.lineTo(stopLineX, roadBottom);
        ctx.stroke();
      }

      function drawLight() {
        ctx.save();
        ctx.translate(stopLineX + 26, roadTop - 16);
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(-8, 0, 16, roadBottom - roadTop + 40);

        ctx.fillStyle = '#0b1220';
        ctx.strokeStyle = '#1f2937';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.roundRect(-16, 12, 32, 86, 12);
        ctx.fill();
        ctx.stroke();

        const lights = ['#ef4444', '#eab308', '#22c55e'];
        ['red', 'yellow', 'green'].forEach((name, i) => {
          const y = 28 + i * 28;
          const isActive = light.phase.name === name;
          ctx.fillStyle = isActive ? lights[i] : 'rgba(148,163,184,0.25)';
          ctx.beginPath();
          ctx.arc(0, y, 9, 0, Math.PI * 2);
          ctx.fill();
          if (isActive) {
            const gradient = ctx.createRadialGradient(0, y, 2, 0, y, 16);
            gradient.addColorStop(0, lights[i]);
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(0, y, 18, 0, Math.PI * 2);
            ctx.fill();
          }
        });
        ctx.restore();
      }

      function drawCars() {
        cars.forEach((car) => {
          ctx.save();
          ctx.translate(car.x, car.y);
          ctx.fillStyle = car.color;
          ctx.shadowColor = car.color + '70';
          ctx.shadowBlur = 18;
          ctx.fillRoundRect(0, -car.height / 2, car.width, car.height, 6);
          ctx.fillStyle = 'rgba(15,23,42,0.6)';
          ctx.fillRoundRect(6, -car.height / 2 + 2, car.width - 12, car.height - 6, 4);
          ctx.restore();
        });
      }

      function drawOverlays() {
        const lamps = {
          green: document.getElementById('lamp-green'),
          yellow: document.getElementById('lamp-yellow'),
          red: document.getElementById('lamp-red')
        };
        Object.values(lamps).forEach((lamp) => lamp.classList.remove('on', 'green', 'yellow', 'red'));
        const active = lamps[light.phase.name];
        if (active) {
          active.classList.add('on', light.phase.name);
        }
      }

      function draw(queues) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawRoad();
        drawLight();
        drawCars();
        drawOverlays();
      }

      if (!ctx.roundRect) {
        CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
          if (w < 2 * r) r = w / 2;
          if (h < 2 * r) r = h / 2;
          this.beginPath();
          this.moveTo(x + r, y);
          this.arcTo(x + w, y, x + w, y + h, r);
          this.arcTo(x + w, y + h, x, y + h, r);
          this.arcTo(x, y + h, x, y, r);
          this.arcTo(x, y, x + w, y, r);
          this.closePath();
          return this;
        };
      }

      CanvasRenderingContext2D.prototype.fillRoundRect = function (x, y, w, h, r) {
        this.roundRect(x, y, w, h, r);
        this.fill();
      };

      let last = performance.now();
      function frame(now) {
        const delta = Math.min(0.05, (now - last) / 1000);
        last = now;
        update(delta);
        requestAnimationFrame(frame);
      }

      spawnCar();
      spawnCar();
      requestAnimationFrame(frame);
    </script>
  </body>
</html>
