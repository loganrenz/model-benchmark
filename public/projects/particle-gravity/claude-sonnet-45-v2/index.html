<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Particle Gravity Simulation</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: linear-gradient(to bottom, #0f2027, #203a43, #2c5364);
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: monospace;
    }
    canvas {
      background: linear-gradient(180deg, #1a1a3e 0%, #0a0a1e 100%);
      border-radius: 8px;
      box-shadow: 
        0 0 40px rgba(0, 0, 0, 0.5),
        inset 0 0 60px rgba(0, 0, 0, 0.3);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = 800;
    canvas.height = 700;
    
    class Ball {
      constructor(index) {
        this.spawn(index);
      }
      
      spawn(index) {
        const angle = (index / 25) * Math.PI * 2;
        const spread = 150;
        
        this.x = canvas.width / 2 + Math.cos(angle) * spread;
        this.y = 50 + Math.sin(angle) * 30;
        this.vx = (Math.random() - 0.5) * 5;
        this.vy = 0;
        this.r = 7 + Math.random() * 5;
        
        // Rainbow colors
        const hue = (index * 360 / 25) % 360;
        this.hue = hue;
        this.color = `hsl(${hue}, 85%, 65%)`;
      }
      
      update() {
        // Gravity
        this.vy += 0.35;
        
        this.x += this.vx;
        this.y += this.vy;
        
        // Floor collision
        if (this.y + this.r > canvas.height) {
          this.y = canvas.height - this.r;
          this.vy *= -0.8;
          this.vx *= 0.97;
          
          // Add random impulse occasionally
          if (Math.random() < 0.01) {
            this.vy = -8 - Math.random() * 4;
          }
        }
        
        // Wall collisions
        if (this.x - this.r < 0) {
          this.x = this.r;
          this.vx *= -0.8;
        } else if (this.x + this.r > canvas.width) {
          this.x = canvas.width - this.r;
          this.vx *= -0.8;
        }
        
        // Ceiling
        if (this.y - this.r < 0) {
          this.y = this.r;
          this.vy *= -0.7;
        }
      }
      
      draw() {
        // Outer glow
        const glowGradient = ctx.createRadialGradient(
          this.x, this.y, 0,
          this.x, this.y, this.r * 3
        );
        glowGradient.addColorStop(0, this.color + 'ff');
        glowGradient.addColorStop(0.4, this.color + '44');
        glowGradient.addColorStop(1, this.color + '00');
        
        ctx.fillStyle = glowGradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r * 3, 0, Math.PI * 2);
        ctx.fill();
        
        // Main ball
        const mainGradient = ctx.createRadialGradient(
          this.x - this.r * 0.4,
          this.y - this.r * 0.4,
          0,
          this.x,
          this.y,
          this.r * 1.2
        );
        mainGradient.addColorStop(0, '#ffffff');
        mainGradient.addColorStop(0.2, this.color);
        mainGradient.addColorStop(1, `hsl(${this.hue}, 85%, 40%)`);
        
        ctx.fillStyle = mainGradient;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.fill();
        
        // Edge highlight
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    
    // Create balls
    const balls = [];
    for (let i = 0; i < 25; i++) {
      balls.push(new Ball(i));
    }
    
    // Animation
    function draw() {
      // Fade effect
      ctx.fillStyle = 'rgba(26, 26, 62, 0.15)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Ground line
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, canvas.height);
      ctx.lineTo(canvas.width, canvas.height);
      ctx.stroke();
      
      balls.forEach(ball => {
        ball.update();
        ball.draw();
      });
      
      requestAnimationFrame(draw);
    }
    
    draw();
  </script>
</body>
</html>
